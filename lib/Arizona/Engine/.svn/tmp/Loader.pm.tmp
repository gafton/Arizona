=pod
=head1 NAME

WA::Engine::Loader

=head1 DESCRIPTION

Not /really/ a controller, this is a wrapper for dynamically loading
remoteable modules from places like phoenix.pl and old school
Mason templates.

=cut

##########################################################################

use MooseX::Declare;

class WA::Engine::Loader {
    
    use Method::Signatures::Simple name => 'action';

##########################################################################
=pod

=over

=item call

Loads a module by name, and invokes a method from within that module.
Intended for use by webapps (phoenix) as well as Mason code.  Most users
will want to use invoke() or invoke_json() which provide sugar for this method.

=back

=cut
##########################################################################


    action call($module, $method, $wa_user, $params, $request, $rest) {

         my $input_data = undef;
         die 'user is missing' unless defined $wa_user;
         
         # REST methods only get to view the "data"
         # portion of the POST, not other parameters.  This means they
         # won't see "noun", "verb", and URL parameters.  
		   
        if ($rest) {
             eval {
                 $input_data = WA::Model::Forge->instance->json->decode($request->body());

             } or die WA::Err::Forbidden->new(text => "invalid JSON: " . $request->body());
        } else {

                # this is not a /Rest/ URL, but there may still be POSTDATA
                # allows for pseudo-REST submission of a JSON response in a form
                # via a classic POST, used by student side to avoid a duplicate
                # request.  'data' field must have a JSON value.  We don't support
                # classic HTML form submission.

                # FIXME: use $request params here?
                if ( $request->body() =~ /^data\=/ ) {
                    # Strip off "data=".
                    my $body = $request->body();
                    $body = substr($body, 5);

                    my $post_data = '';
                    eval {
                        $post_data = WA::Model::Forge->instance->json->decode($body);
                    } or die WA::Err::Forbidden->new( text => "Could not decode request body: " .  $@ . $request->body() );

                    $params->{post} = $post_data;

                } else {
                    $params->{post} = {};
                }

        }
			
         # in the controller, JSON/REST API methods start with "API_" and view
         # only pages for humans start with "PAGE_".   There are no pages
         # that cause state change, by convention.  All submissions happen
         # over JSON/REST.
         my $method_name = sprintf "%s_$method", $rest ? 'API' : 'RENDER';

         # modules have to start with WA::, which prevents requesting to run
         # methods in other classes.  This is in addition to the method name
         # restrictions above.  
         die WA::Err::Forbidden->new(text => "disallowed: $module") unless $module =~ /^([A-Za-z0-9:_])+$/;
         die WA::Err::Forbidden->new(text => "invalid: $module") unless $module =~ /^WA::Controller::/;

         # instantiate the controller class
         my $obj;
         eval {
             $obj = $module->new();
         } or do {
             # either a syntax error or an invalid path, though we won't tell userland.
             # developers check for syntax errors by doing 'perl WA/Controller/Foo/Bar.pm'
             # and make sure your URLs are correct.
             die WA::Err::InternalError->new(text => "cannot load requested module: $module");
         }; 

         my $result = '';
         # JSON/REST methods get the "data" field only.  Controller methods
         # get all form variables and query strings, though they should ONLY
         # expect query strings since they are only intended for view rendering
         # and All Submissions Must Be Ajax.
         if ($rest) {
             $result = $obj->$method_name($wa_user, $input_data, $request);
             die WA::Err::InternalError->new(text => 'improper return') unless $result->isa('WA::Engine::Return');
             return $result->to_json_str();
         } 
         return $obj->$method_name($wa_user, $params, $request);
    }

##########################################################################
=pod

=over

=item invoke_rest

Call a JSON/REST function by name.

=back

=cut
##########################################################################

   action invoke_rest($class_and_method, $wa_user, $params, $request) {
       my ($class, $method) = $self->__get_parts($class_and_method);
       unless (ref $wa_user) {
           $wa_user = WA::Model::User->find_one({id => $wa_user});
       }
       return $self->call($class, $method, $wa_user, $params, $request, 1);
   }

   # used to split data out of the URL.
   action __get_parts($class_and_method) {
       my @tokens = split /::/, $class_and_method;
       my $method = $tokens[-1];
       pop(@tokens);
       my $class = join '::', @tokens;
       return ($class, $method);
   }

##########################################################################
=pod

=over

=item invoke

Call a non-REST (view only page) function by name.  These pages are not
allowed to make state changes.

=back

=cut
##########################################################################

   action invoke($class_and_method, $wa_user, $params, $request) {

       my ($class, $method) = $self->__get_parts($class_and_method);
       unless (ref $wa_user) {
           my $user = WA::Model::User->find_one({id => $wa_user});
       }
       return $self->call($class, $method, $wa_user, $params, $request, 0);
   }    

}
